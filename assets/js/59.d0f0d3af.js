(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{434:function(e,a,t){"use strict";t.r(a);var s=t(14),n=Object(s.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"diseno-de-memoria-en-wgsl"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diseno-de-memoria-en-wgsl"}},[e._v("#")]),e._v(" Diseño de Memoria en WGSL")]),e._v(" "),a("div",{staticClass:"warn"},[a("p",[e._v("Esta página se está reelaborando actualmente. Quiero entender los temas un poco mejor, pero como la versión 0.12 ya está disponible, quiero lanzar lo que tengo por ahora.")])]),e._v(" "),a("h2",{attrs:{id:"alineacion-de-buferes-de-vertices-e-indices"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alineacion-de-buferes-de-vertices-e-indices"}},[e._v("#")]),e._v(" Alineación de búferes de vértices e índices")]),e._v(" "),a("p",[e._v("Los búferes de vértices requieren definir un "),a("code",[e._v("VertexBufferLayout")]),e._v(", por lo que la alineación de memoria es lo que le indiques a WebGPU que debe ser. Esto puede ser muy conveniente para reducir el uso de memoria en la GPU.")]),e._v(" "),a("p",[e._v("El búfer de índices utiliza la alineación del tipo primitivo que especifiques a través del "),a("code",[e._v("IndexFormat")]),e._v(" que pasas a "),a("code",[e._v("RenderEncoder::set_index_buffer()")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"alineacion-de-buferes-uniform-y-storage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alineacion-de-buferes-uniform-y-storage"}},[e._v("#")]),e._v(" Alineación de búferes Uniform y Storage")]),e._v(" "),a("p",[e._v("Los GPUs están diseñados para procesar miles de píxeles en paralelo. Para lograr esto, fue necesario hacer algunos sacrificios. El hardware gráfico prefiere que todos los bytes que pretendas procesar estén alineados por potencias de 2. Los detalles exactos de por qué ocurre esto están más allá de mi nivel de conocimiento, pero es importante saberlo para que puedas solucionar los problemas por los que tus shaders no funcionan correctamente.")]),e._v(" "),a("p",[e._v("Echemos un vistazo a la siguiente tabla:")]),e._v(" "),a("hr"),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Type")]),e._v(" "),a("th",[e._v("Alignment in Bytes")]),e._v(" "),a("th",[e._v("Size in Bytes")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("scalar (i32, u32, f32)")]),e._v(" "),a("td",[e._v("4")]),e._v(" "),a("td",[e._v("4")])]),e._v(" "),a("tr",[a("td",[e._v("vec2<T>")]),e._v(" "),a("td",[e._v("8")]),e._v(" "),a("td",[e._v("8")])]),e._v(" "),a("tr",[a("td",[e._v("vec3<T>")]),e._v(" "),a("td",[a("strong",[e._v("16")])]),e._v(" "),a("td",[e._v("12")])]),e._v(" "),a("tr",[a("td",[e._v("vec4<T>")]),e._v(" "),a("td",[e._v("16")]),e._v(" "),a("td",[e._v("16")])])])]),e._v(" "),a("p",[e._v("Puedes ver que para "),a("code",[e._v("vec3")]),e._v(" la alineación es la siguiente potencia de 2 respecto al tamaño, 16. Esto puede sorprender a principiantes (e incluso a veteranos) ya que no es la más intuitiva. Esto se vuelve especialmente importante cuando comenzamos a distribuir structs. Tomemos el struct de luz del "),a("RouterLink",{attrs:{to:"/intermediate/tutorial10-lighting/#seeing-the-light"}},[e._v("tutorial de iluminación")]),e._v(":")],1),e._v(" "),a("p",[e._v("Puedes ver la tabla completa de alineaciones en la sección "),a("a",{attrs:{href:"https://www.w3.org/TR/WGSL/#alignment-and-size",target:"_blank",rel:"noopener noreferrer"}},[e._v("4.3.7.1 de la especificación WGSL"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language-wgsl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-wgsl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Light")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    position"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("vec3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("f32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    color"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("vec3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("f32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("¿Cuál es entonces la alineación de este struct? Tu primera suposición sería que es la suma de las alineaciones de los campos individuales. Eso podría tener sentido si estuviéramos en el mundo de Rust, pero en el mundo de los shaders, es un poco más complicado. La alineación de un struct dado se da por la siguiente ecuación:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// S is the struct in question\n// M is a member of the struct\nAlignOf(S) = max(AlignOfMember(S, M1), ... , AlignOfMember(S, Mn))\n")])])]),a("p",[e._v("Básicamente, la alineación del struct es el máximo de las alineaciones de los miembros del struct. Esto significa que:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("AlignOf(Light) \n    = max(AlignOfMember(Light, position), AlignOfMember(Light, color))\n    = max(16, 16)\n    = 16\n")])])]),a("p",[e._v("Por eso "),a("code",[e._v("LightUniform")]),e._v(" tiene esos campos de relleno. WGPU no lo aceptará si los datos no están alineados correctamente.")]),e._v(" "),a("h2",{attrs:{id:"como-lidiar-con-problemas-de-alineacion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#como-lidiar-con-problemas-de-alineacion"}},[e._v("#")]),e._v(" Cómo lidiar con problemas de alineación")]),e._v(" "),a("p",[e._v("En general, 16 es la alineación máxima que verás. En ese caso, podrías pensar que deberíamos ser capaces de hacer algo como lo siguiente:")]),e._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[e._v("#[repr(C, align(16))]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token attribute attr-name"}},[e._v("#[derive(Debug, Copy, Clone, bytemuck::Pod, bytemuck::Zeroable)]")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("struct")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token type-definition class-name"}},[e._v("LightUniform")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    position"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("f32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    color"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("f32")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Pero esto no compilará. El "),a("a",{attrs:{href:"https://docs.rs/bytemuck/",target:"_blank",rel:"noopener noreferrer"}},[e._v("crate bytemuck"),a("OutboundLink")],1),e._v(" no funciona con structs que tienen bytes de relleno implícitos. Rust no puede garantizar que la memoria entre los campos se haya inicializado correctamente. Esto me dio un error cuando lo intenté:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("error[E0512]: cannot transmute between types of different sizes, or dependently-sized types\n   --\x3e code/intermediate/tutorial10-lighting/src/main.rs:246:8\n    |\n246 | struct LightUniform {\n    |        ^^^^^^^^^^^^\n    |\n    = note: source type: `LightUniform` (256 bits)\n    = note: target type: `_::{closure#0}::TypeWithoutPadding` (192 bits)\n")])])]),a("h2",{attrs:{id:"recursos-adicionales"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recursos-adicionales"}},[e._v("#")]),e._v(" Recursos adicionales")]),e._v(" "),a("p",[e._v("Si estás buscando más información, consulta el "),a("a",{attrs:{href:"https://gist.github.com/teoxoy/936891c16c2a3d1c3c5e7204ac6cd76c",target:"_blank",rel:"noopener noreferrer"}},[e._v("artículo"),a("OutboundLink")],1),e._v(" de @teoxoy.")])])}),[],!1,null,null,null);a.default=n.exports}}]);