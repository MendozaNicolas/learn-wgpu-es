(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{426:function(e,o,a){"use strict";a.r(o);var r=a(14),i=Object(r.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"¡primera-version-mayor-22-0"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#¡primera-version-mayor-22-0"}},[e._v("#")]),e._v(" ¡Primera Versión Mayor! (22.0)")]),e._v(" "),o("p",[e._v("Aquí solo hay algunos cambios. Primero, todas las estructuras de\nconfiguración relacionadas con shaders ahora tienen un campo "),o("code",[e._v("compilation_options")]),e._v(".\nPor ahora simplemente lo estoy dejando como "),o("code",[e._v("Default::default()")]),e._v(", pero si\ntienes necesidades específicas de compilación está disponible para ti.")]),e._v(" "),o("p",[e._v("Lo siguiente es que "),o("code",[e._v("RenderPipelineDescriptor")]),e._v(" y "),o("code",[e._v("ComputePipelineDescriptor")]),e._v("\nahora tienen un campo "),o("code",[e._v("cache")]),e._v(". Esto te permite proporcionar un caché para\nusar durante la compilación de shaders. Esto es realmente útil solo para\ndispositivos Android ya que la mayoría del hardware de escritorio y los\ncontroladores proporcionan caché. Lo he dejado como "),o("code",[e._v("None")]),e._v(" por ahora.")]),e._v(" "),o("p",[o("code",[e._v("DeviceDescriptor")]),e._v(" ahora tiene un campo "),o("code",[e._v("memory_hint")]),e._v(". Puedes usar esto para\npedirle a la GPU que priorice el rendimiento, el uso de memoria, o permitirte\nsolicitar un tamaño de bloque de memoria personalizado. Sin embargo, estas\nson solo sugerencias y el hardware tiene la palabra final en cómo hacer las\ncosas. Lo he dejado como "),o("code",[e._v("Default::default()")]),e._v(" por ahora.")])])}),[],!1,null,null,null);o.default=i.exports}}]);